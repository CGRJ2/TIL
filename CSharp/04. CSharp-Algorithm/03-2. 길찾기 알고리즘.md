
# ê¸¸ì°¾ê¸° ì•Œê³ ë¦¬ì¦˜
 
	ê°€ì¤‘ì¹˜ ê·¸ë˜í”„ì—ì„œì˜ íƒìƒ‰ 

# ğŸŸ¢ ë‹¤ìµìŠ¤íŠ¸ë¼ ì•Œê³ ë¦¬ì¦˜
ì‹œê°í™” ì‚¬ì´íŠ¸ https://www.cs.usfca.edu/~galles/visualization/Dijkstra.html

> íŠ¹ì •í•œ ë…¸ë“œì—ì„œ ì¶œë°œí•˜ì—¬ ë‹¤ë¥¸ ë…¸ë“œê¹Œì§€ ê°€ëŠ” ê°ê°ì˜ ìµœë‹¨ ê²½ë¡œë¥¼ êµ¬í•˜ëŠ” ì•Œê³ ë¦¬ì¦˜

> ë°©ë¬¸í•˜ì§€ ì•Šì€ ë…¸ë“œ ì¤‘ì—ì„œ ê°€ì¥ ê°€ê¹Œìš´ ë…¸ë“œë¥¼ ì„ íƒí•œ í›„,
> ì„ íƒí•œ ë…¸ë“œë¥¼ ê±°ì³ì„œ ë” ì§§ì•„ì§€ëŠ” ê²½ë¡œê°€ ìˆëŠ” ê²½ìš° ëŒ€ì²´

```csharp
const int INF = 99999; // ì—°ê²°ë˜ì§€ ì•Šì•˜ìŒì„ í‘œí˜„í•˜ëŠ” ê°’

public static void Dijkstra(int[,] graph, int start, out bool[] visited, out int[] parents, out int[] cost)
{
    int size = graph.GetLength(0);
    visited = new bool[size];
    parents = new int[size];
    cost = new int[size];

    // ì´ˆê¸° ì„¤ì •
    for (int i = 0; i < size; i++)
    {
        visited[i] = false;
        parents[i] = -1;
        cost[i] = INF;
    }
    cost[start] = 0;


    for (int i = 0; i < size; i++)
    {
        int minIndex = -1;
        int minCost = INF;

		// í˜„ì¬ ë…¸ë“œ
        for (int j = 0; j < size; j++)
        {
            // ë°©ë¬¸í•˜ì§€ ì•Šì€ ì •ì  ì¤‘ ê°€ì¥ ê°€ê¹Œìš´ ì •ì  ì„ íƒ
            if (visited[j] == false && cost[j] < minCost)
            {
                minIndex = j;
                minCost = cost[j];
            }
        }
        if (minIndex < 0) break; // ëª¨ë“  ì •ì ë“¤ì„ ì´ë¯¸ ë°©ë¬¸í•œ ê²½ìš° íƒˆì¶œ.
        visited[minIndex] = true;

        // ( ì§ì ‘ ì—°ê²°ëœ ê±°ë¦¬ > ê±°ì³ê°€ëŠ” ê±°ë¦¬ ) ì¸ ê²½ìš° ëŒ€ì²´
        for (int j = 0; j < size; j++)
        {
            // cost[j]              : ëª©ì ì§€ê¹Œì§€ ì§ì ‘ ì—°ê²°ëœ ê±°ë¦¬   (AB)
            // cost[minIndex]       : ì¤‘ê°„ì ê¹Œì§€ ì§ì ‘ ì—°ê²°ëœ ê±°ë¦¬   (AC)
            // graph[minIndex, j]   : ì¤‘ê°„ì ë¶€í„° ëª©ì ì§€ê¹Œì§€ ê±°ë¦¬    (CB)
            if (cost[j] > cost[minIndex] + graph[minIndex, j])
            {
                cost[j] = cost[minIndex] + graph[minIndex, j];
                parents[j] = minIndex;
            }
        }
    }
}
```

(ì§ì ‘ êµ¬í˜„ ì—°ìŠµ)
```csharp
public static void Dijkstra(int[,] graph, int start, out bool[] visited, out int[] parents, out int[] cost)
{
    // ê²°ê³¼ë¬¼ì„ ë‹´ì„ ê³³
    int size = graph.GetLength(0);
    visited = new bool[size];
    parents = new int[size];
    cost = new int[size];

    // ì´ˆê¸°í™”
    for (int i = 0; i < size; i++)
    {
        visited[i] = false;
        parents[i] = -1;
        cost[i] = INF;
    }
    cost[start] = 0;

    int nodeCount = 0;
    while (nodeCount < size)
    {
        nodeCount++;

        int nowNode = -1;
        int nowCost = INF;

        // ì—°ê²°ëœ ìµœì € ì½”ìŠ¤íŠ¸ ë…¸ë“œ ì°¾ê¸°
        for (int i = 0; i < size; i++)
        {
            if (visited[i] == false && cost[i] < nowCost)
            {
                nowNode = i;
                nowCost = cost[i];
            }
        }
        if (nowNode < 0) return; // ì—†ìœ¼ë©´ ë
        visited[nowNode] = true; // ì°¾ì€ í˜„ì¬ ë…¸ë“œ ë°©ë¬¸ ì²´í¬

        // í˜„ì¬ ë…¸ë“œì™€ ì—°ê²°ëœ ë…¸ë“œ ì°¾ê¸°
        for (int i = 0; i < size; i++)
        {
            // í˜„ì¬ ë…¸ë“œì™€ ì—°ê²°ë˜ì–´ ìˆë‹¤ë©´
            // nowCost = í˜„ì¬ ë…¸ë“œì˜ ì´ ì½”ìŠ¤íŠ¸
            // graph[nowNode, i] = í˜„ì¬ ë…¸ë“œì™€ ì—°ê²°ëœ ë…¸ë“œ ì‚¬ì´ì˜ ê°€ì¤‘ì¹˜
            if (cost[i] > nowCost + graph[nowNode, i] && graph[nowNode, i] < INF)
            {
                cost[i] = nowCost + graph[nowNode, i];
                parents[i] = nowNode;
            }
        }
    }
```

ì‚¬ìš©
```csharp
static void Main(string[] args)
{
    const int INF = 99999; // ì—°ê²°ë˜ì§€ ì•Šì•˜ìŒì„ í‘œí˜„í•˜ëŠ” ê°’
    int[,] dijkstraTestGraph = new int[8, 8]
    {
        { 0, 7, INF, INF, INF, INF, INF, INF },
        { 7, 0, INF, 5, INF, INF, 9, INF },
        { INF, INF, INF, INF, INF, INF, 5, INF },
        { INF, 5, INF, INF, INF, INF, INF, INF },
        { INF, INF, INF, INF, INF, INF, INF, INF },
        { INF, INF, INF, INF, INF, INF, 9, INF },
        { INF, INF, 5, INF, INF, 9, INF, INF },
        { INF, INF, INF, INF, INF, INF, INF, INF }
    };

    bool[] visited;
    int[] parents;
    int[] cost;

    Dijkstra(dijkstraTestGraph, 0, out visited, out parents, out cost);

	for (int i = 0; i < visited.Length; i++)
    {
        if (cost[i] == INF)
            Console.WriteLine($"Vertex : {i}\t\tê¸¸ ì—¬ë¶€ : {visited[i]}\t\tCost : INF\t\të¶€ëª¨ : {parents[i]}");
        else
            Console.WriteLine($"Vertex : {i}\t\tê¸¸ ì—¬ë¶€ : {visited[i]}\t\tCost : {cost[i]}\t\të¶€ëª¨ : {parents[i]}");

    }
}
```

---

# ğŸŸ¢ íœ´ë¦¬ìŠ¤í‹± ì•Œê³ ë¦¬ì¦˜

> ëª©í‘œê¹Œì§€ ë‚¨ì€ ê±°ë¦¬(ë¹„ìš©)ì˜ **ì¶”ì •ì¹˜**

ì¥ì 
> 1. ê²½ë¡œ ì˜ˆì¸¡      ->  ëª©í‘œê¹Œì§€ ì–¼ë§ˆë‚˜ ë‚¨ì•˜ëŠ”ì§€ **ëŒ€ëµì ìœ¼ë¡œ ì¶”ì •**
> 2. íƒìƒ‰ ìµœì í™”  ->  ëœ ìœ ë§í•œ ê²½ë¡œëŠ” í”¼í•˜ê³ , **ë” ìœ ë§í•œ ê²½ë¡œë¶€í„° íƒìƒ‰**
> 3. ì„±ëŠ¥ í–¥ìƒ      ->  ë‹¤ìµìŠ¤íŠ¸ë¼ë³´ë‹¤ ë¹ ë¥´ê²Œ ë„ë‹¬ ê°€ëŠ¥ (ë¶ˆí•„ìš”í•œ ë…¸ë“œ ëœ íƒìƒ‰)


```csharp
public struct Point
{
    public int X;
    public int Y;
    public Point(int x, int y) { X = x; Y = y; }
}

// ë§¨í•´íŠ¼ ê±°ë¦¬ (ìƒí•˜ì¢Œìš°)
public static int ManhattanDistance(Point a, Point b)
{
    return Math.Abs(a.X - b.X) + Math.Abs(a.Y - b.Y);
}

// ìœ í´ë¦¬ë“œ ê±°ë¦¬(float) (ëŒ€ê°í¬í•¨ ììœ ì´ë™)
public static float EuclideanDistance(Point a, Point b)
{
    int dx = a.X - b.X;
    int dy = a.Y - b.Y;
    return (float)Math.Sqrt(dx * dx + dy * dy);
}

// ëŒ€ê°ì„  ê±°ë¦¬ (8ë°©í–¥ ì´ë™)
public static int DiagonalDistance(Point a, Point b)
{
    return Math.Max(Math.Abs(a.X - b.X), Math.Abs(a.Y - b.Y));
}
```