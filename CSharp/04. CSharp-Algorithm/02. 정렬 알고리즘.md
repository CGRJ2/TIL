20250402

---

# 1. ì„ íƒ ì •ë ¬ (Selection Sort)

>ë°ì´í„° ì¤‘ ê°€ì¥ ì‘ì€ ê°’ë¶€í„° í•˜ë‚˜ì”© ì„ íƒí•˜ì—¬ ì•ë¶€ë¶„ ë¶€í„° ì •ë ¬

	ì‹œê°„ë³µì¡ë„ - O(nÂ²)
	ê³µê°„ë³µì¡ë„ - O(1)
	ì•ˆì •ì •ë ¬ - âŒ (ë™ì¼ ê°’ì˜ ìˆœì„œê°€ ë°”ë€” ìˆ˜ ìˆìŒ)

| ì¥ì   | êµ¬í˜„ì´ ê°„ë‹¨, ë©”ëª¨ë¦¬ ì‚¬ìš© ì ìŒ    |
| --- | -------------------- |
| ë‹¨ì   | ëŠë¦° ì†ë„ (ëŒ€ê·œëª¨ ë°ì´í„°ì— ë¶€ì í•©) |
#### í‰ê°€
>ì„ íƒì •ë ¬ì€ ì „ì²´ ë°ì´í„°ë¥¼ ë§¤ë²ˆ ìˆœíšŒí•˜ë©´ì„œ ê°€ì¥ ì‘ì€ ê°’ì„ ì„ íƒí•˜ì—¬ ì•ìª½ì— ë°°ì¹˜í•˜ëŠ” ë°©ì‹ìœ¼ë¡œ, **ì‹œê°„ë³µì¡ë„ëŠ” O(nÂ²)** ë¡œ íš¨ìœ¨ì´ ë‚®ì€ í¸ì´ë‹¤.  
>í•˜ì§€ë§Œ ì •ë ¬ ê³¼ì •ì—ì„œ **ì¶”ê°€ ë©”ëª¨ë¦¬ë¥¼ ì‚¬ìš©í•˜ì§€ ì•Šê³ **, ë°°ì—´ ë‚´ë¶€ì—ì„œë§Œ ê°’ë“¤ì„ êµí™˜(in-place)í•˜ê¸° ë•Œë¬¸ì— **ê³µê°„ë³µì¡ë„ëŠ” O(1)** ë¡œ ë©”ëª¨ë¦¬ ì‚¬ìš©ì€ íš¨ìœ¨ì ì´ë‹¤.  
>ë‹¨, ë™ì¼í•œ ê°’ì˜ ìƒëŒ€ì  ìˆœì„œê°€ ë°”ë€” ìˆ˜ ìˆì–´ **ë¶ˆì•ˆì • ì •ë ¬ì´ë‹¤.**  ì˜ˆ) ( 1, 1, 2 ) -> 1ë“¤ë¼ë¦¬ ë°”ë€œ

	í•œì¤„í‰ : ëŠë¦¬ì§€ë§Œ êµ¬í˜„ì€ ì‰½ë‹¤.

``` csharp
public static void SelectionSort(int[] array)
{
    for (int i = 0; i < array.Length; i++)
    {
        int minIndex = i;
        for (int j = i + 1; j < array.Length; j++)
        {
            if (array[j] < array[minIndex]) minIndex = j;
        }

        int temp = array[minIndex];
        array[minIndex] = array[i];
        array[i] = temp;
    }
}
```

---
# 2. ì‚½ì… ì •ë ¬ (Insertion Sort)

>ì•ì—ì„œë¶€í„° ë°ì´í„°ë¥¼ í•˜ë‚˜ì”© êº¼ë‚´ì–´ **ìì‹ ë³´ë‹¤ ì•ì— ìˆëŠ” ë°ì´í„°ë“¤ê³¼ ë¹„êµ**,  
>**ìë¦¬ë¥¼ ì°¾ì•„ ì‚½ì…**í•˜ë©° ì •ë ¬ (ì•ìª½ì— ìê¸°ë³´ë‹¤ í° ë°ì´í„°ê°€ ì—†ì„ ë•Œ ë³¸ì¸ìë¦¬ í™•ì •)

	ì‹œê°„ë³µì¡ë„ -  O(nÂ²)
	ê³µê°„ë³µì¡ë„ -  O(1)
	ì•ˆì •ì •ë ¬   -  ğŸŸ¢
#### í‰ê°€
> ì‚½ì…ì •ë ¬ì€ ì •ë ¬ì´ ì–´ëŠ ì •ë„ ë˜ì–´ ìˆëŠ” ê²½ìš° ë§¤ìš° ë¹ ë¥´ê²Œ ë™ì‘í•œë‹¤.  
> ì „ì²´ ë°°ì—´ì„ í•œêº¼ë²ˆì— ì •ë ¬í•˜ê¸°ë³´ë‹¤ëŠ”, 
> **ë¶€ë¶„ì ìœ¼ë¡œ ì •ë ¬í•´ë‚˜ê°€ëŠ” ë°©ì‹**ì´ë¼ ì§ê´€ì ì´ê³  íš¨ìœ¨ì ì¸ ë©´ì´ ìˆë‹¤.  
> íŠ¹íˆ ë°ì´í„°ê°€ ê±°ì˜ ì •ë ¬ëœ ìƒíƒœë¼ë©´ O(n)ì— ê°€ê¹Œìš´ ì„±ëŠ¥ì„ ë³´ì¼ ìˆ˜ë„ ìˆë‹¤.
 
	í•œì¤„í‰ : ì ì€ ë°ì´í„°ì— ì¢‹ë‹¤.

```csharp
// ì´ë˜ë„ ë˜ê³ 
public static void InsertionSort(int[] array) 
{
    // ì™¼ìª½(i-1)ì´ë‘ ë¹„êµí•´ì•¼ í•˜ë‹ˆê¹Œ [1]ë¶€í„° ì‹œì‘
    for (int i = 1; i < array.Length; i++)  
    {
        // [i]ì—ì„œ [1]ê¹Œì§€ ì™¼ìª½ì— ì¸ì ‘í•œ ë°ì´í„°ì™€ ë¹„êµ
        for (int j = i; j > 0; j--)   
        {                             
            // ì™¼ìª½ë³´ë‹¤ ë‚´ê°€ ë” ì‘ë‹¤ë©´ ìœ„ì¹˜ ë³€ê²½ (ì™¼ìª½ìœ¼ë¡œ ì´ë™)
            if (array[j - 1] > array[j])
            {
                int temp = array[j - 1];
                array[j - 1] = array[j];
                array[j] = temp;
            }
            // ë‚´ê°€ ë” í¬ë‹¤ë©´ ì´ë²ˆ íšŒì°¨ ë°˜ë³µ ì¢…ë£Œ. i++
            else break;
        }
    }
}

// ì´ë˜ë„ ë˜ê³ 
public static void InsertionSort(int[] array)
{
    // ì™¼ìª½(i-1)ì´ë‘ ë¹„êµí•´ì•¼ í•˜ë‹ˆê¹Œ [1]ë¶€í„° ì‹œì‘
    for (int i = 1; i < array.Length; i++)
    {
        int nowData = array[i]; // í˜„ì¬ ë°ì´í„°
        
        int j = i - 1; // í˜„ì¬ ë°ì´í„° ì™¼ìª½ë¶€í„° << ë°©í–¥ìœ¼ë¡œ ë°ì´í„° ë¹„êµ
        // ì™¼ìª½ì— ìˆëŠ” ë°ì´í„°ê°€ [0]ë²ˆ ì´ìƒì´ë¼ë©´ && ì™¼ìª½ì— ìˆëŠ” ì• ê°€ ë” í¬ë‹¤ë©´ ê³„ì† ë°˜ë³µ
        while (j >= 0 && array[j] > nowData) 
        {
	        // nowDataìë¦¬(array[j + 1])ì— array[j]ê°’ ë„£ì–´ì£¼ê¸°.
            array[j + 1] = array[j];
            j--;
        }
        // ì™¼ìª½ ë°ì´í„°ê°€ í¬ì§€ ì•Šë‹¤! whileë¬¸ íƒˆì¶œ í›„, ìë¦¬ í™•ì •
        array[j + 1] = nowData;
    }
}
```



# 3. ë²„ë¸” ì •ë ¬ (Bubble Sort)

>ë°ì´í„°ë¥¼ ìˆœì°¨ì ìœ¼ë¡œ ë¹„êµí•˜ë©° **ì¸ì ‘í•œ ë‘ ê°’ì„ ë°”ê¿”ê°€ë©° ì •ë ¬**  
>ê°€ì¥ í° ê°’ì´ ë§¤ ë£¨í”„ë§ˆë‹¤ ë§¨ ë’¤ë¡œ "ë²„ë¸”ì²˜ëŸ¼" ë°€ë ¤ë‚¨

	ì‹œê°„ë³µì¡ë„ -  O(nÂ²)
	ê³µê°„ë³µì¡ë„ -  O(1)
	ì•ˆì •ì •ë ¬   -  ğŸŸ¢
#### í‰ê°€
> ë²„ë¸”ì •ë ¬ì€ êµ¬í˜„ì´ ë§¤ìš° ê°„ë‹¨í•˜ê³ , ì•ˆì • ì •ë ¬ì´ì§€ë§Œ  
> ë§¤ë²ˆ ì¸ì ‘í•œ ê°’ë“¤ì„ êµí™˜í•˜ëŠ” ë°©ì‹ì´ë¼ **íš¨ìœ¨ì´ ë§¤ìš° ë‚®ë‹¤.**  
> ë°ì´í„°ê°€ ê±°ì˜ ì •ë ¬ëœ ìƒíƒœë¼ë©´ **ì¡°ê¸° ì¢…ë£Œ ìµœì í™”**ë¡œ ì„±ëŠ¥ì´ ì•½ê°„ ê°œì„ ë  ìˆ˜ ìˆìŒ.

	í•œì¤„í‰ : ì˜ ì•ˆì”€...

```csharp
// ë‘ê°œì”© ë¹„êµí•˜ê³  ë‹¤ ëŒì•˜ìœ¼ë©´ ë‹¤ì‹œ ì²˜ìŒë¶€í„° ë‘ê°œì”© ë¹„êµ.
public static void BubbleSort(int[] array)
{
	// ì „ì²´ ë°˜ë³µ íšŸìˆ˜ (ë°”ê¹¥ ë°˜ë³µë¬¸) = n - 1  // *n: ë°°ì—´ ê¸¸ì´
	// ë§¤ íšŒì°¨ë§ˆë‹¤ ê°€ì¥ í° ê°’ì„ ë§¨ ë’¤ë¡œ ë³´ë‚´,
	// (n - 1) ë²ˆì§¸ íšŒì°¨ì— ì´ë¯¸ ì •ë ¬ì´ ì™„ë£Œë˜ê¸° ë•Œë¬¸
    for (int i = 0; i < array.Length - 1; i++)   
    {
        bool swaped = false;  // í•œë°”í€´ë§ˆë‹¤ ì •ë ¬ ì™„ë£Œí–ˆëŠ”ì§€ í™•ì¸ : ì„±ëŠ¥ ê°œì„ ìš©
		
		
        for (int j = 0; j < array.Length - i - 1; j++)   
        {
            // ì™¼ìª½ì´ ë” í¬ë‹¤ë©´ ìœ„ì¹˜ ë°”ê¿”ì£¼ê¸° --> ë°°ì—´ ì‹œì‘ë¶€í„° ëê¹Œì§€ ìŒìœ¼ë¡œ ë¹„êµ
            if (array[j] > array[j + 1])
            {
                int temp = array[j];
                array[j] = array[j + 1];
                array[j + 1] = temp;
                swaped = true;
            }
        }
        // í•œë°”í€´ ëŒì•˜ì„ ë•Œ, ëª¨ë“  ì¸ì ‘ ë°ì´í„° ìŒ ê°„ì˜ êµí™˜ì´ ì—†ì„ ë•Œ 
        // => ì •ë ¬ ì™„ë£Œ ë¼ëŠ” ëœ»ì´ë‹ˆê¹Œ ì¡°ê¸°ì¢…ë£Œ.
        if (!swaped) break;   
    }
}
```


---
# 4. ë³‘í•© ì •ë ¬ (Merge Sort)

> ë°ì´í„°ë¥¼ ë°˜ìœ¼ë¡œ ë‚˜ëˆ  ì •ë ¬ í›„ í•©ë³‘
> ë°ì´í„° ê°¯ìˆ˜ë§Œí¼ì˜ ì¶”ê°€ì ì¸ ë©”ëª¨ë¦¬ê°€ í•„ìš”

	ì‹œê°„ë³µì¡ë„ -  O(nlogn)
	ê³µê°„ë³µì¡ë„ -  O(n)
	ì•ˆì •ì •ë ¬   -  ğŸŸ¢

| ì¥ì   | ì‹œê°„ë³µì¡ë„ **O(n log n)** (í•­ìƒ ì¼ì •), ì•ˆì • ì •ë ¬   |
| --- | ------------------------------------- |
| ë‹¨ì   | **ì¶”ê°€ ë©”ëª¨ë¦¬ ì‚¬ìš© O(n)** í•„ìš” (ë³‘í•© ê²°ê³¼ ì €ì¥ìš© ë¦¬ìŠ¤íŠ¸) |
#### í‰ê°€
> **ë°ì´í„° ì–‘ì´ ë§ê³  ì •ë ¬ ì•ˆì •ì„±ì´ í•„ìš”í•œ ê²½ìš°** ë§¤ìš° ìœ ë¦¬ (ex. ì´ë¦„ìˆœ, ë‚ ì§œìˆœ)
> í•˜ì§€ë§Œ ë©”ëª¨ë¦¬ ì‚¬ìš©ì´ ì»¤ì„œ ëª¨ë°”ì¼ í™˜ê²½ ë“± ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ì— ë¯¼ê°í•œ ê³³ì— ë¶€ì í•©

	í•œì¤„í‰ : ì•ˆì •ì ì´ì§€ë§Œ ë©”ëª¨ë¦¬ ì‚¬ìš©ì´ í¬ë‹¤.

```csharp
public static void MergeSort(IList<int> list, int start, int end)
{
    if (start == end) return;

    int mid = (start + end) / 2;
    
    // ì¬ê·€í•¨ìˆ˜ë¡œ ë°˜ìœ¼ë¡œ ë˜ ë‚˜ëˆ”! ex) 16 -> 8 -> 4 -> 2
    MergeSort(list, start, mid);   // ì ˆë°˜ ì•ë¶€ë¶„ 
    MergeSort(list, mid + 1, end); // ì ˆë°˜ ë’·ë¶€ë¶„
    Merge(list, start, mid, end);  //
}

private static void Merge(IList<int> list, int start, int mid, int end)
{
    List<int> sortedList = new List<int>(); // ì •ë ¬ëœ ë°ì´í„°ë¥¼ ë„£ëŠ” ë°°ì—´
    
    int leftIndex = start;
    int rightIndex = mid + 1;

    while (leftIndex <= mid && rightIndex <= end)
    {
        if (list[leftIndex] < list[rightIndex])
        {
            sortedList.Add(list[leftIndex++]);
        }
        else
        {
            sortedList.Add(list[rightIndex++]);
        }
    }

    // ë‚¨ì•„ìˆëŠ” ê²ƒë“¤ì„ ì •ë ¬ëœ ë¦¬ìŠ¤íŠ¸ì— ì¶”ê°€
    if (leftIndex > mid) // ì™¼ìª½
    {
        for (int i = rightIndex; i <= end; i++)
        {
            sortedList.Add(list[i]);
        }
    }
    else // if (rightIndex > end) // ì˜¤ë¥¸ìª½
    {
        for (int i = leftIndex; i <= mid; i++)
        {
            sortedList.Add(list[i]);
        }
    }

    // ì •ë ¬ëœ ë°°ì—´ë¡œ ë°”ê¿”ì£¼ê¸°
    for (int i = 0; i < sortedList.Count; i++)
    {
        list[start + i] = sortedList[i];
    }
}
```

---
# 5. í€µ ì •ë ¬ (Quick Sort)

> í•˜ë‚˜ì˜ í”¼ë²—ì„ ê¸°ì¤€ìœ¼ë¡œ ì‘ì€ê°’ê³¼ í°ê°’ì„ 2ë¶„í• í•˜ì—¬ ì •ë ¬
> ìµœì•…ì˜ ê²½ìš°(í”¼ë²—ì´ ìµœì†Œê°’ ë˜ëŠ” ìµœëŒ€ê°’)ì¸ ê²½ìš° ì‹œê°„ë³µì¡ë„ê°€ O(nÂ²)

	ì‹œê°„ë³µì¡ë„ -  í‰ê·  : O(nlogn)   ìµœì•… : O(nÂ²)
	ê³µê°„ë³µì¡ë„ -  O(1)
	ì•ˆì •ì •ë ¬   -  X

| ì¥ì   | **ì œìë¦¬ ì •ë ¬** O(1) ê³µê°„, í‰ê·  ì‹œê°„ë³µì¡ë„ **O(n log n)**    |
| --- | ---------------------------------------------- |
| ë‹¨ì   | **ìµœì•…ì˜ ê²½ìš° O(nÂ²)** (ì´ë¯¸ ì •ë ¬ëœ ë°°ì—´ì— ì ìš©í•˜ë©´), **ë¶ˆì•ˆì • ì •ë ¬** |
#### í‰ê°€
> ì‹¤ì œë¡œ ê°€ì¥ ë¹ ë¥¸ ì •ë ¬ ì•Œê³ ë¦¬ì¦˜ ì¤‘ í•˜ë‚˜
> ì •ë ¬ ë¼ì´ë¸ŒëŸ¬ë¦¬ì—ì„œ ê¸°ë³¸ìœ¼ë¡œ ì“°ì´ëŠ” ê²½ìš°ê°€ ë§ìŒ
> **ìºì‹œ ì¹œí™”ë„ ë†’ìŒ** â†’ ì„±ëŠ¥ì´ ì´ë¡ ë³´ë‹¤ ë” ì˜ ë‚˜ì˜´ 
> (ë³‘í•© ì •ë ¬ë³´ë‹¤ ì‹¤ì§ˆì ìœ¼ë¡œ ë¹ ë¦„)

	í•œì¤„í‰ : ìºì‹œ íš¨ìœ¨ì´ ì¢‹ì•„ì„œ ì´ë¡ ë³´ë‹¤ ì„±ëŠ¥ì´ ë” ì˜ë‚˜ì˜¨ë‹¤.

```csharp
// í”¼ë²— ì„¤ì • ì•ˆí•  ë•Œ
public static void QuickSort(IList<int> list) => QuickSort(list, 0, list.Count - 1);

public static void QuickSort(IList<int> list, int start, int end)
{
    if (start >= end) return;
	
	int pivot = start;
    int left = pivot + 1;
    int right = end;
	
    while (left <= right)
    {
        while (list[left] <= list[pivot] && left < right)
        {
            left++;
        }
        while (list[right] > list[pivot] && left <= right)
        {
            right--;
        }
	
        if (left < right)
        {
            Swap(list, left, right);
        }
        else
        {
            Swap(list, pivot, right);
            break;
        }
    }
	
    QuickSort(list, start, right - 1);
    QuickSort(list, right + 1, end);
}
```

---
# 6. í™ ì •ë ¬Â (Heap Sort)

> í™ì„ ì´ìš©í•˜ì—¬ ìš°ì„ ìˆœìœ„ê°€ ê°€ì¥ ë†’ì€ ìš”ì†Œê°€ ê°€ì¥ ë§ˆì§€ë§‰ ìš”ì†Œì™€ êµì²´ëœ í›„ ì œê±°ë˜ëŠ” ë°©ë²•ì„ ì´ìš©.
> ë°°ì—´ì—ì„œ ì—°ì†ì ì¸ ë°ì´í„°ë¥¼ ì‚¬ìš©í•˜ì§€ ì•Šê¸° ë•Œë¬¸ì— 
> ìºì‹œ ë©”ëª¨ë¦¬ë¥¼ íš¨ìœ¨ì ìœ¼ë¡œ ì‚¬ìš©í•  ìˆ˜ ì—†ì–´ ìƒëŒ€ì ìœ¼ë¡œ ëŠë¦¼

	ì‹œê°„ë³µì¡ë„ -  O(nlogn)
	ê³µê°„ë³µì¡ë„ -  O(1)
	ì•ˆì •ì •ë ¬   -  X

| ì¥ì   | í•­ìƒ **ì‹œê°„ë³µì¡ë„ O(n log n)**, ìµœì•…ì—ë„ ì¼ì •          |
| --- | ----------------------------------------- |
| ë‹¨ì   | ì •ë ¬ì´ ëŠë¦¼ (ìºì‹œ ë¹„íš¨ìœ¨ì , ë…¸ë“œ ì ‘ê·¼ì´ ë„ì—„ë„ì—„), **ë¶ˆì•ˆì • ì •ë ¬** |
#### í‰ê°€
> **ìµœì•… ì‹œê°„ë³µì¡ë„ê°€ ì¤‘ìš”í•œ í™˜ê²½**ì— ì í•© (ex. ë³´ì•ˆ, ì‹¤ì‹œê°„ ì‹œìŠ¤í…œ)
> ë©”ëª¨ë¦¬ ì‚¬ìš©ì€ íš¨ìœ¨ì ì´ì§€ë§Œ, ìºì‹œ íš¨ìœ¨ì´ ë‚®ì•„ **ì‹¤ì œë¡œëŠ” í€µë³´ë‹¤ ëŠë¦¬ë‹¤.**

	í•œì¤„í‰ : ì¼ì •í•¨ì€ ì¥ì , ì†ë„ëŠ” ì´ë¡ ë§Œí¼ ë¹ ë¥´ì§€ ì•ŠìŒ

```csharp
public static void HeapSort(IList<int> list)
{
    MakeHeap(list);

    for (int i = list.Count - 1; i > 0; i--)
    {
        Swap(list, 0, i);
        Heapify(list, 0, i);
    }
}

private static void MakeHeap(IList<int> list)
{
    for (int i = list.Count / 2 - 1; i >= 0; i--)
    {
        Heapify(list, i, list.Count);
    }
}

private static void Heapify(IList<int> list, int index, int size)
{
    int left = index * 2 + 1;
    int right = index * 2 + 2;
    int max = index;
    if (left < size && list[left] > list[max])
    {
        max = left;
    }
    if (right < size && list[right] > list[max])
    {
        max = right;
    }

    if (max != index)
    {
        Swap(list, index, max);
        Heapify(list, max, size);
    }
}
```


---






# ê·¸ë˜ì„œ ì •ë ¬ì„ ì•Œì•„ì•¼í•˜ëŠ” ì´ìœ ê°€ ë­”ë°?

![[Pasted image 20250402151718.png]]

ì™œ í€µì •ë ¬ì´ ìµœì•…ì˜ ê²½ìš°ê°€ nì œê³±ì¸ë°ë„ í™ì •ë ¬ë³´ë‹¤ ë¹ ë¥´ì§€?

í™ì •ë ¬ì˜ íŠ¹ì§• í•˜ë‚˜ê°€ ìˆëŠ”ë°.
ì»´í“¨í„°ëŠ” ë­‰íƒœê¸°ë¡œ ê°€ì ¸ì™€ì„œ ì“°ëŠ”ê²Œ ìœ ë¦¬í•œë°
í™ì€ ë„ì—„ë„ì—„
í€µì€ ìºì‹œì¹œí™”ë„ê°€ ë†’ìŒ

ì´ë¡ ìƒìœ¼ë¡  í™ì´ ë” ë¹ ë¥´ì§€ë§Œ í€µì •ë ¬ì´ ìºì‹œì ì¤‘ë¥ (ìºì‹œì¹œí™”ë„)ê°€ ë†’ê¸°ë•Œë¬¸ì— ì‹¤ì œë¡œ í€µì´ ë” ë¹ ë¦„

(ì—°ê²°ë¦¬ìŠ¤íŠ¸ë„ ê·¸ë¬ì§€. ì´ë¡ ìƒ ì™„ë²½í•˜ê³  ì œì¼ íš¨ìœ¨ì ìœ¼ë¡œ ë³´ì´ì§€ë§Œ ìºì‹œì¹œí™”ë„ê°€ ë‚®ì•„ì„œ ì˜ ì•ˆì“´ë‹¤ëŠ”ê±°.)



---
####  ë°°ì—´ë¿ë§Œ ì•„ë‹ˆë¼ ë¦¬ìŠ¤íŠ¸ë„ ì •ë ¬í•  ìˆ˜ ìˆëŠ” í•¨ìˆ˜ë¥¼ ë§Œë“œë ¤ë©´?
	`IList<int>` ë¥¼ ì¸ìë¡œ ì‚¬ìš©í•˜ë©´ ë¨.
```csharp

// ë°°ì—´ë§Œ ë°›ì„ ìˆ˜ë„ 
public static void Sort(int[] array) 
// ë¦¬ìŠ¤íŠ¸ë§Œ ë°›ì„ ìˆ˜ë„ ìˆì§€ë§Œ
public static void Sort(List<int> list) 

// IListë¥¼ í†µí•´ ë°°ì—´/ë¦¬ìŠ¤íŠ¸ ë‘˜ë‹¤ ë°›ê²Œ í•  ìˆ˜ ìˆìŒ
public static void Sort(IList<int> list) 
```

---
# ì •ìˆ˜ê°€ ì•„ë‹ ë• ë¬´ì—‡ìœ¼ë¡œ ëŒ€ì†Œë¹„êµë¥¼ í•˜ëŠ”ê°€?

> ë¬¸ìì—´: ì •ìˆ˜ì²˜ëŸ¼ Sort()í•¨ìˆ˜ì— ë‚´ì¥ë˜ì–´ ìˆìŒ. (ì˜ì–´:ëŒ€ë¬¸ì -> ì†Œë¬¸ì ìˆœ, ì•ŒíŒŒë²³ìˆœ | í•œê¸€: ì‚¬ì „ìˆœ)

    ex) { "Abc", "Bdea", "C", "aBED", "c", "dae" }

> í´ë˜ìŠ¤: `IComparable<í´ë˜ìŠ¤>` ì¸í„°í˜ì´ìŠ¤ë¥¼ êµ¬í˜„í•´ ë¹„êµí•´ì¤„ ê¸°ì¤€ì„ ì •í•  ìˆ˜ ìˆìŒ.
> `IComparable` ì¸í„°í˜ì´ìŠ¤ ì† `CompareTo` í•¨ìˆ˜ì—ì„œ ë¹„êµ ê¸°ì¤€ì„ ì •í•´ì¤Œ.

	ex) `Player` í´ë˜ìŠ¤ë¥¼ `Score` ìˆœìœ¼ë¡œ ì •ë ¬

```csharp
public class Player : IComparable<Player>
{
    public string Name;
    public int Score;

    public int CompareTo(Player other)
    {
        return this.Score.CompareTo(other.Score);  // ë¹„êµ ê¸°ì¤€ì„ Scoreë¡œ ì •í•¨!
    }
}

public static void Main()
{
    List<Player> players = new List<Player>
    {
        new Player { Name = "íƒ€ë½íŒŒì›Œì „ì‚¬", Score = 200 },
        new Player { Name = "ì§€ì¡´ê¶ìˆ˜", Score = 150 },
        new Player { Name = "ë²ˆê°œì˜ì‹ ", Score = 300 }
    };

    players.Sort();     // ì˜¤ë¦„ì°¨ìˆœ ì •ë ¬
    players.Reverse();  // ì •ë ¬ ë’¤ì§‘ê¸° -> ë‚´ë¦¼ì°¨ìˆœ ì •ë ¬
    for (int i = 0; i < players.Count; i++)
    {
        Console.WriteLine($"{i + 1}ë“± : {players[i].Name}");
    }
	
	// ì¶œë ¥
	// 1ë“± : ë²ˆê°œì˜ì‹ 
	// 2ë“± : íƒ€ë½íŒŒì›Œì „ì‚¬
	// 3ë“± : ì§€ì¡´ê¶ìˆ˜
}
```

---



# ì¸íŠ¸ë¡œ ì •ë ¬ (Intro Sort)

#### ì¸íŠ¸ë¡œ ì •ë ¬ì´ë€?

**IntroSort**
	> í€µì†ŒíŠ¸(QuickSort)ì˜ ë¹ ë¥¸ ì„±ëŠ¥ì„ í™œìš©í•˜ë˜,  
	> **ìŠ¤íƒ ê¹Šì´ê°€ ì¼ì • ì´ìƒìœ¼ë¡œ ê¹Šì–´ì§€ë©´ í™ì†ŒíŠ¸(HeapSort)**ë¡œ ì „í™˜í•˜ê³ ,  
	> ì‘ì€ ì˜ì—­ì€ ì‚½ì…ì •ë ¬(InsertionSort)ì„ ì“°ëŠ” **í•˜ì´ë¸Œë¦¬ë“œ ì •ë ¬ ì•Œê³ ë¦¬ì¦˜**
	
	>>> ìƒí™©ì— ë§ì¶°ì„œ í•˜ì´ë¸Œë¦¬ë“œë¡œ ëŒì•„ê°€ëŠ” ì •ë ¬ì´ë‹¤!

| ì•Œê³ ë¦¬ì¦˜                  | ì–¸ì œ ì“°ì´ëŠ”ê°€            | ì¥ì                      |
| --------------------- | ------------------ | ---------------------- |
| í€µ ì •ë ¬ (QuickSort)      | í‰ê· ì ì¸ ì •ë ¬            | ë¹ ë¥¸ ì„±ëŠ¥                  |
| í™ ì •ë ¬ (HeapSort)       | ì¬ê·€ ê¹Šì´ê°€ ë„ˆë¬´ ê¹Šì–´ì§ˆ ë•Œ    | ìµœì•…ì˜ ì‹œê°„ë³µì¡ë„ ë°©ì§€           |
| ì‚½ì… ì •ë ¬ (InsertionSort) | í•­ëª© ìˆ˜ê°€ ì ì„ ë•Œ (16 ì´í•˜) | ë§¤ìš° ë¹ ë¦„ (O(nÂ²)ì´ì–´ë„ ìƒìˆ˜ ì‘ìŒ) |

	"ì‚½ì… ì •ë ¬O(nÂ²)ì€ ë¹„íš¨ìœ¨ì ì´ì§€ ì•Šë‚˜ìš”?"

í€µ ì •ë ¬ê³¼ ê°™ì€ O(nlogn) êµ¬ì¡°ëŠ” íš¨ìœ¨ì ì´ì§€ë§Œ, ì‚¬ì „ì‘ì—…ì´ í•„ìš”í•¨.
ë•Œë¬¸ì—, *ë°ì´í„° í¬ê¸°ê°€ ì ì„ ë•ŒëŠ” ì‚½ì…ì •ë ¬ì´ í€µì •ë ¬ë³´ë‹¤ ë¹ ë¥´ë‹¤.*


#### C#ì—ì„œ ì§€ì›í•˜ëŠ” ê¸°ë³¸ ì •ë ¬
`List<T>.Sort()`, `Array.Sort()`ì˜ ë‚´ë¶€ ì •ë ¬ ì•Œê³ ë¦¬ì¦˜ì€ "ì¸íŠ¸ë¡œ ì •ë ¬(Intro Sort)" ê¸°ë°˜ì´ë‹¤

```csharp
int[] array = {1,2,3,4,5};
List<int> list = {1,2,3,4,5}

// C#ì—ì„œ ê¸°ë³¸ì§€ì›í•˜ëŠ” ì •ë ¬ (ì¸íŠ¸ë¡œ ì •ë ¬ ê¸°ë°˜)
Array.Sort(array);
list.Sort();
```

------

ì •ë ¬ ì•Œê³ ë¦¬ì¦˜ ì‹œê°í™” ì‚¬ì´íŠ¸
https://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html

ëŒ€ê·œëª¨ ë­ì‹œê¸°ëŠ” Tim Sortë¥¼ ì“´ëŒ€